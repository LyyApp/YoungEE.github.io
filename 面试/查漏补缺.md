1、load和initialize
 +load方法：
    此方法会在这个类或者分类被添加到运行时调用，实现这个方法可以在类加载的时候去执行一些类相关的行为。
    加载消息被发送到动态加载和静态链接的类和类别，但只有新加载的类和分类才会响应这个方法
    初始化的顺序如下: 在任何框架链接到你所有的初始化;
    			   所有的负载方法在您的镜像；
    			   所有的c++静态初始化器和c/c++使用attribute(构造函数)函数在你的镜像
    			   所有的初始化框架连接到你
    子类的load方法都会在其父类之后进行调用
    分类的load方法都会在其本类之后进行调用

	加载顺序
      所有的类和分类的+load方法都是在被加入到runtime的时候调用
      父类优先于子类加载，内部通过递归的方式实现
      在所有本类加载完毕之后再去加载各个分类
      同一类的多个分类加载顺序是你添加的顺序

+initialize：
    runtime会在每个类及其子类收到第一条消息(类方法/对象方法)之前调用initialize，也就是说不能主动通过[super initialize]方法调用
    父类早于子类调用
    初始化的时候是在安全线程调用的，因此不要写复杂的逻辑(复杂的逻辑容易引起死锁)
    如果子类没有实现initialize方法，其父类的该方法会被调用多次
    如果想避免initialize方法被调用多次可以使用筛选类名的方法进行避免
    该方法的每个类只会被调用一次，如果想对某个类或其分类进行独立初始化，可以通过+load方法

总结：
	正常情况下(即没有在load方法中调用相关类的方法),load和initialize方法都在实例化对象之前调用，load相当于装载方法，都在mian()函数之前调用，initialize方法都在main()函数之后调用。
	如果在A类的load方法中调用B类的类方法，那么在调用A的load方法之前，会先调用一下B类的initialize方法，但是B类的load方法还是按照Compile Source顺序进行加载
	所有类的load方法都会被调用，先调用父类、在调用子类多个分类会按照Compile Sources顺序加载，但是initialize方法会被覆盖，子类父类分类中只会执行一个
	load方法内部一般用来实现Method Swizzling，initialize方法一般都是用来初始化全局变量或者静态变量
	两个方法都不能主动被调用，也不需要通过super集成父类方法，但是initialize方法会在子类没有实现的时候调用父类的该方法，load不会


2、websocket和http长连接的区别？
   http：
   	 http1.x：一次请求响应建立一个连接，用完关闭
   	 http1.1：串行化单线程处理，可以同时在同一个tcp链接上发送多个请求，但是只有响应是有顺序的，只有上一个请求完成后，下一个才响应，一旦有任务处理超时，后续任务只能被阻塞
   	 HTTP2：并行执行，某些任务耗时严重，不会影响到任务的正常执行。

   Websocket是html5提出的一个协议规范，是为解决客户端与服务端实时通信。本质上是一个基于tcp，先通过HTTP/HTTPS协议发起一条特殊的http请求进行握手后创建一个用户交互数据的TCP连接。他的优势是浏览器和服务器只需要做一个握手的动作，在建立连接之后，双方可以在任意时刻相互推送信息。同时，服务器与客户端之间交换的头信息很小

   短连接：链接->传输数据->关闭链接
   长连接:链接->传输数据->保持链接->传输数据->。。。->关闭链接

   他们两者的区别是：
   	http1.1通过使用Connection：keep-alive进行长连接，http1.1默认进行持久链接，在一次TCP链接中可以完成多个HTTP请求，但是对每个请求仍然要单独发header，Keep-alive不会永久保持链接，他有一个保持时间，可以在不同的服务器软件(apache)中设定这个时间，这种长连接是一种“伪连接”。

   	websocket的长连接，是一个真正的全双工，长连接第一次tcp链路建立之后，后续数据可以双方都进行发送，不需要发送请求头

   	keep-alive双方并没有简历真正的链接会话，服务端可以在任何一次请求完成后关闭。websocket它本身就规定了是真正的，双工的长连接，两边都必须要维持住连接的状态

3、僵尸对象(Zombie Object)原理
   僵尸对象是一种用来检测内存错误(exc_bad_access)的对象，它可以捕获任何对尝试访问坏内存的调用。
   如果给僵尸对象发送消息时，那么将在运行期间崩溃和输出错误日志。通过日志可以定位到野指针对象调用的方法和类名

   系统在回收对象时，可以不将其真的回收，而是把它转化成僵尸对象。这种对象所在的内存无法重用，因此不可遭到重写，所以将随机变成必然。
   系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够相应所有的选择器，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序


4、APP启动过程

	解析info.plist，Mach-O加载，程序执行
	APP启动后系统首先加载可执行文件(自身AOO的所有.O文件的集合)，然后加载动态链接器dyld，dyld是一个专门用来加载动态链接库的库，执行从dyld开始，dyld从可执行文件的依赖开始，递归加载所有的依赖动态链接库

5、AFN2.0和AFN3.0
  2.0是通过封装NSURLConnection来实现的。3.0是通过封装NSURLSession来实现的，因为ios9.0以后NSURLConnection被弃用，苹果推荐使用NSURLSession来管理网络请求
  
  2.0：1、有常驻线程：可以避免多个网络请求，就要保活多个线程
       2、并发请求，和代理回调都在同一线程（常驻线程），所以线程等待回调
       3、并发请求：系统根据实际情况控制并发请求
       4、2。0的operationQueue是用于并发请求的

  3.0：1、无需常驻线程，因为NSURLSession可以指定回调的delegateQueue，NSURLConnection而不行。
      2、最大并发数设置：3.0的operationQueue是用于接收NSURLSessionDelegate回调的。当他的最大并发数self.operationQueue.maxConcurrentOperationCount = 1,是为了达到穿心回调的效果，况且加了锁，加锁是为了防止多线程资源竞争加了锁（对 self.mutableTaskDelegatesKeyedByTaskIdentifier(多任务代理)的访问进行加锁），本来就需要等待，如果多线程并发反而造成资源浪费





