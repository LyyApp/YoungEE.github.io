关键字

Strong：表示指向并拥有该对象，其修饰的引用计数会加1，该对象只要引用计数不为0则不会被销毁，如果要销毁此对象只能强制置位nil
Weak：表示指向但是不拥有该对象，其修饰的对象不会增加引用计数，无需手动设置，该对象会自行在内存中销毁
Assign：主要用于修饰基本数据类型，如NSInteger和CGFloat，这些主要存在于栈上面，
Copy：和strong类似，不同点在于strong的复制是多个指针指向同一块区域，copy复制每次都会在内存中拷贝一份对象，指针指向不同的地址，copy一般用来修饰有可变对应类型的不可变对象上，如NSString,nsarray和NSDictionary等等

空指针，悬垂指针和野指针？
空指针：指针指向的地址为空的指针
悬垂指针：指针指向的内存地址已经被释放或者销毁，但是指针地址还存在，也叫迷途指针
野指针：没有进行初始化的指针

Assign修饰对象出现的情况详见面试准备第一天项目中的Assign修饰对象




堆，栈的意思以及区别？






1、assign和weak区别
 assgin：修饰基本类型数据如int float,bool；修饰对象类型时，不改变其引用计数；assign修饰对象类型时，当再次访问修饰的对象时会因为悬垂指针的原因而导致内存泄漏
 weak：不改变被修饰对象的引用计数，所修饰的对象被废弃或者被释放后会自动设置成nil 
 区别为：①assign既能修饰基本数据类型也能修饰对象类型，weak只能修饰对象类型，②assign修饰对象时当对象释放后指针还是会指向原来的内存地址 ，weak修饰的对象释放后会自动设置成nil

2、浅拷贝和深拷贝？
 浅拷贝就是对内存地址的复制，让目标对象的指针和原指针指向同一块内存空间，增加了内存区块的引用计数
 深拷贝让目标对象和源对象指针指向两块内容相同内存空间，不会增加引用计数

3、如何区分浅拷贝和深拷贝？
 ①是否开辟了新的内存空间  ②是否增加了引用计数

4、copy关键字
 4种不同的的类型
 可变对象-->copy-->不可变对象--->深拷贝
 可变对象-->mutableCoy-->可变对象-->深拷贝
 不可变对象-->copy-->不可变对象-->浅拷贝
 不可变对象-->mutableCopy-->可变对象-->深拷贝

 可变对象的copy和mutableCopy都是深拷贝
 不可变对象的copy是浅拷贝，mutablecopy是深拷贝
 copy方法返回的都是不可变对象
 具体详见代码

5、@property(copy) NSMutableArray *array   有什么问题？
 执行这条语句 实际上就是进行的 可变对象的copy操作  copy操作完后可变对象变成不可变对象NSArray 拷贝类型为深拷贝  当在对操作完后的对象NSArray 进行增删改后会出现crash

6、atomic和notomic的区别
 atomic:原子性，默认属性，会保证CPU在别的线程访问这个属性之前，先执行完当前的流程，所以速度比较慢
 nonomic:不是默认的，访问速度很快，线程不安全，如果有两个或者多个线程同时访问会出现意想不到的结果

7、为什么说atomic修饰的属性不能完全确保线程的安全？
 atomic修饰的属性只是对属性的getter/setter方法进行加锁，这种安全仅仅只是读写的安全，并非真正意义上的安全。如果用线程A调用调用getter，B和C 调用Setter，那么最终得到的值可能是原始值,B,C设值中的一种，真正意义上的线程安全除了读写还有一些其他的操作，比如当我在调用getter/setter方法的时候，另外一个线程同事调用release，可能会直接crash


 
