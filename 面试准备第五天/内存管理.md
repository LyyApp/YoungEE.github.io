 1、内存管理包含哪些我们要掌握的
  内存布局，内存管理方案，数据结构，ARC&MRC,引用计数，弱引用，自动释放池(autoreleasepool),循环引用

 内存布局
 1、内存布局图
 从高到低依次为
   				内核区
   				栈（stack）向下扩展，向下增长
   				堆（heap）向上增长
   				未初始化数据（.bbs）
   				已初始化数据(.data)
   				代码段(.text)
   				
2、不同的内存端代表的什么？
 stack：函数调用开销，比如局部变量，分配的地址空间越来越小
 heap:通过alloc，malloc,calloc等动态分配的空间，分配的地址空间越来越大
 bbs:未初始化的全局变量等
 data:已初始化的全局变量等
 text:程序代码

内存管理方案
1、ios根据不同的场景提供不同的内存管理方案
 TaggedPointer：小对象如NSnumber
 NONPOINTER_ISA:64为架构下ios应用程序，这个非指针型的ISA其中30或者40位是代表类的，剩余的地址存放了一些关于内存管理相关的内容
 散列表:复杂的数据结构包括引用计数表，弱应用计数表

2、NONPOINTER_ISA详解
 arm64为的架构，isa指针一共有64位

 第一位:indexed：0或者1，0代表这个isa指针为指针型ISA 64为代表类的地址，1代表这个isa指针为非指针型ISA其中只有一部分位数就能代表类的地址
 第二位：has_assoc：0或者1，0代表没有关联对象，1代表有关联对象
 第三位：has_cxx_dtor  表示当前对象是否有使用到c++的代码  
 第四到35位：shiftcls当前对象的类对象的指针地址
 第36到41位 ：magic
 第42位：weakly_rederenced：弱引用 表示当前对象是否是弱引用
 第43位：deallocating 表示当前对象是否在进行dealloc操作
 第44位：has_sidetable_rc 当前isa指针如果达到上限了需要去外挂一个额外的引用计数表去存储当前超过上限的引用计数
 第45位到最后一位：extra_rc 额外的引用计数的存储

3、散列表
1、SideTables()结构 
 SideTables其实就是一个哈希表，可以通过对象指针可以具体找到相对应的引用计数表或者弱引用计数表具体在哪一张iSdeTable中

2、SideTable结构
 SideTable包含自旋锁(spinlock_t),引用技术表(RefcountMap),弱引用表(weak_table_t)

3、为什么不是一个SideTable而是由多个SideTable组成的SidesTables这样一个数据结构呢?
 如果只有一个表那么程序所创建的成千上万个对象都存放在一个大表里面,如果我们要操作某一个对象的引用计数时,那么操作表,操作表的时候必须对表加锁而其他对象要操作表的时候就必须等待前一个操作完后把锁释放掉了在进行操作，如果有很多对象都要对这个表进行操作那么就存在效率问题。

4、分离锁
 把对象的引用技术表分拆成多个，分拆后多分拆后的表进行加锁，多个表进行并行操作，从而提高效率

5、怎样实现快速分流(如何通过对象指针快速的找到它属于哪张SideTable表中)
 SideTable的本质是一张Hash表，通过哈希算法进行快速查找，将对象的地址作为key，从sideTables中取得相对应的表，然后对表在进行哈希查找找到对应的对象。哈希算法的目的就是大大的提高了查找的效率






